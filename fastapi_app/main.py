from fastapi import FastAPI
from fastapi import Response, Request
from fastapi.responses import HTMLResponse
from fastapi.responses import JSONResponse, FileResponse
from typing import Callable
import json
from fastapi.staticfiles import StaticFiles
from db import engine, Base
import os
import logging
from fastapi.middleware.cors import CORSMiddleware
from pydantic import ValidationError
from sqlalchemy.exc import SQLAlchemyError
import time
import asyncio
from pathlib import Path

from fastapi_app.routes.members import router as members_router
from fastapi_app.routes.team_display import router as team_router
from fastapi_app.routes.qr import router as qr_router
from fastapi_app.routes.pdf import router as pdf_router
from fastapi_app.routes.admin import router as admin_router
# auto-generated by TRAE

Base.metadata.create_all(bind=engine)

app = FastAPI()

# --- Absolute Path Setup (Fixes Windows Path Issues) ---
# This ensures we always point to .../backend/fastapi_app/static/
BASE_DIR = Path(__file__).resolve().parent
STATIC_DIR = BASE_DIR / "static"

os.makedirs(STATIC_DIR, exist_ok=True)

app.mount("/static", StaticFiles(directory=str(STATIC_DIR)), name="static")

app.add_middleware(
    CORSMiddleware,
    allow_origins=[
        "http://localhost:3000",
        "http://127.0.0.1:3000",
        "http://localhost:5173",
        "http://127.0.0.1:5173",
    ],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*", "X-API-Key"],
)

app.include_router(members_router)
app.include_router(team_router)
app.include_router(qr_router)
app.include_router(pdf_router)
app.include_router(admin_router)

@app.get("/favicon.ico", include_in_schema=False)
async def favicon():
    # Explicitly looks for favicon in the absolute static path
    file_path = STATIC_DIR / "favicon.ico"
    if file_path.exists():
        return FileResponse(file_path, media_type="image/x-icon")
    return Response(status_code=404)

@app.get("/")
def home():
    return {"status": "Backend Running"}

@app.get("/__whoami")
def whoami():
    return {
        "main_file": __file__,
        "routers": ["members", "team", "qr", "pdf", "admin"],
    }

@app.get("/__routes_debug")
def routes_debug():
    return {
        "loaded": [{"path": r.path, "name": r.name} for r in app.routes]
    }

@app.get("/debug", response_class=HTMLResponse)
def debug_page():
    from db import engine, DATABASE_URL
    routers = ["members", "team", "qr", "pdf", "admin"]
    html = "".join([
        "<h1>Debug</h1>",
        f"<p>Main: {__file__}</p>",
        f"<p>DB URL: {DATABASE_URL}</p>",
        f"<p>Engine: {engine}</p>",
        f"<p>Static: {STATIC_DIR}</p>",
        f"<p>Routers: {', '.join(routers)}</p>",
    ])
    return html

RATE_LIMIT_MAX = 60
RATE_LIMIT_WINDOW = 60.0
_rate_lock = asyncio.Lock()
_rate_buckets: dict[str, list[float]] = {}

@app.middleware("http")
async def rate_limiter(request: Request, call_next: Callable[[Request], Response]) -> Response:
    ip = request.client.host if request.client else "unknown"
    now = time.monotonic()
    async with _rate_lock:
        bucket = _rate_buckets.get(ip, [])
        bucket = [t for t in bucket if now - t < RATE_LIMIT_WINDOW]
        if len(bucket) >= RATE_LIMIT_MAX:
            return JSONResponse(status_code=429, content={"detail": "Too Many Requests"})
        bucket.append(now)
        _rate_buckets[ip] = bucket
    return await call_next(request)

@app.middleware("http")
async def log_exceptions(request: Request, call_next: Callable[[Request], Response]) -> Response:
    try:
        masked_keys = {"cnic", "phone", "membership_id", "qr_code"}
        body = await request.body()
        try:
            data = json.loads(body.decode() or "{}")
            for k in list(data.keys()):
                if k in masked_keys:
                    data[k] = "***"
            log_body = json.dumps(data)
        except Exception:
            log_body = ""
        resp = await call_next(request)
        try:
            content = resp.body.decode()
            rdata = json.loads(content or "{}")
            for k in list(rdata.keys()):
                if k in masked_keys:
                    rdata[k] = "***"
            _ = json.dumps(rdata)
        except Exception:
            pass
        return resp
    except Exception as e:
        logging.exception("Unhandled error")
        return Response(status_code=500, media_type="application/json", content='{"detail":"Internal Server Error"}')

@app.exception_handler(ValidationError)
async def validation_exception_handler(request: Request, exc: ValidationError):
    return JSONResponse(status_code=422, content={"detail": exc.errors()})

@app.exception_handler(SQLAlchemyError)
async def sqlalchemy_exception_handler(request: Request, exc: SQLAlchemyError):
    return JSONResponse(status_code=500, content={"detail": "Database error"})

@app.exception_handler(Exception)
async def generic_exception_handler(request: Request, exc: Exception):
    return JSONResponse(status_code=500, content={"detail": "Server error"})

@app.get("/health")
def health():
    from db import engine, DATABASE_URL
    try:
        with engine.connect() as conn:
            conn.exec_driver_sql("SELECT 1")
        return {"status": "ok", "db": "up", "database_url": DATABASE_URL}
    except Exception:
        return {"status": "ok", "db": "down"}

# Force refresh OpenAPI schema
app.openapi_schema = None
_ = app.openapi()

if __name__ == "__main__":
    import uvicorn
    uvicorn.run("fastapi_app.main:app", host="0.0.0.0", port=8000, reload=True)